/*
	(수열에서의) 탐색?
		- X가 존재하는지?
		- X 이하, 미만, 이상, 초과의 원소는 몇개가 있는지?
		- X랑 가장 가까운 원소는 무엇인지? 
	-> O(N)

	(수열에서의) 탐색 => 만약! 정렬이 되어 있다면?
		정렬된 수열과 탐색 대상 X가 주어졌을 때
		- X가 존재하는지?
		- X 이하, 미만, 이상, 초과의 원소는 몇개가 있는지?
		- X랑 가장 가까운 원소는 무엇인지?
	-> 더 빠르게 할 수 있는 방법이 있다 -> "이분탐색"
	
	이분 탐색 (Binary Search) - 시간복잡도 O(log N)
		"정렬이 보장되는 배열"에서 기준 X를 가지고 범위를 "이분"하면서 탐색하는 방법

	오름차순 정렬이 된 배열의 특성
		1. 임의의 M번 인덱스에 있는 A[M]이 X보다 크다면, A[M...N]은 전부 X보다 크다.
		2. 임의의 M번 인덱스에 있는 A[M]이 X보다 작다면, A[1...M]은 전부 X보다 작다.

	주의! 오름차순 정렬이기 때문에 생기는 성질! 정렬이 아니라면 불가능하다.

	이분 탐색 방법
	L: 탐색할 가치가 있는 범위의 왼쪽 끝 인덱스
	R: 탐색할 가치가 있는 범위의 오른쪽 끝 인덱스
	Result: 탐색한 x의 위치
	탐색 목표 : x이하의 원소 중에 가장 오른쪽에 있는 원소

	시간복잡도? O(log N)
		10만 >>>> log(10만) == 16
	
	자주 하는 실수
		3. L과 R의 범위를 잘못 설정하거나 Result의 초기값을 잘못 설정하는 경우.
		2. L, R, M, Result 변수의 정의를 헷갈려서 부등호 등을 잘못 쓰는 경우.
		1. 입력된 배열에 바로 이분 탐색을 하는데, 정렬을 하지 않는 경우!

*/

// 이분 탐색
const binarySearch = (arr, l, r, num) => {
  let result = l - 1;
  while (l <= r) {
    const mid = parseInt((l + r) / 2, 10);
    if (arr[mid] < num) {
      result = mid;
      l = mid + 1;
    } else if (num <= arr[mid]) {
      r = mid - 1;
    }
  }
  return result;
};
